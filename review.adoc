:toc:
:numbered:

# Red GUI System: a Case Study

## Introduction

This writeup presents analysis of https://www.red-lang.org/[Red programming language]'s approach to Graphical User Interface (GUI) programming in the form of a case study. It concerns itself with https://eugenkiss.github.io/7guis/tasks[7GUIs tasks] implemented in Red, and was conceived as a research on potential improvements in its https://github.com/red/docs/blob/master/en/gui.adoc[GUI system]: cross-platform graphical engine (View), embedded Domain-Specific Language (eDSL) for declarative user interface specification (Visual Interface Dialect, VID) and, to a lesser extent, eDSL for drawing raster graphics (Draw).footnote:[Due to specificity of 7GUIs tasks Rich-Text Dialect (RTD) was not evaluated.]

The study loosely follows the methodology outlined in https://github.com/eugenkiss/7guis/blob/master/thesis.pdf[Eugen Kiss' thesis] that originally presented the idea of benchmarking GUI toolkits in terms of their notational qualities; said benchmark is based on implementing seven GUI-related challenges and evaluating solutions to them using a subset of https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations[Cognitive Dimensions of Notations] (CD) criteria.

The implementation in question is hosted in https://github.com/9214/7guis-red[Github repository], along with the original version of this writeup.

### Overview

A general overview of Red's GUI system in terms of CD is given so as to explain the basic principles, terminology, and conceptual framework pertinent to the case study and all provided solutions; it can be skipped if the reader is familiar with the subject at hand.

#### Abstraction level

> What are the minimum and maximum levels of abstraction exposed by the notation? Can details be encapsulated?

At the lowest level of abstraction GUI is represented as a virtual tree of reactive objects (faces); each such object holds an internal state relevant to a widget that it represents, and inherits its properties from a `face!` prototype.

User interaction happens in an event-based fashion, via a mechanism of https://github.com/red/docs/blob/master/en/view.adoc#two-way-binding[two-way binding]: changes in the underlying OS-specific widget are mapped onto object's state and trigger specified event handlers (actors), and changes in one of the object's properties (facets) are reflected back into widget.

Communication between faces (or faces and domain model) is achieved with the help of object ownership system and https://github.com/red/docs/blob/master/en/reactivity.adoc[reactive framework] built on top of it; graphical component updates can be handled either automatically or with manual change propagation.

Constructing virtual tree of faces manually requires proper initialization of each object and its interconnection with parent and child nodes; this is a cumbersome and error-prone process. As such, at the hight level of abstraction user interface is typically described in declarative fashion via VID dialect, and tree of faces is constructed from such description with one of the View's user-facing functions, `view` or `layout`.

Red GUI system provides a common subset of face types supported by all graphical backends (Win32, Cocoa, GTK, Android). Each backend provides a specific set of guidelines for widget's layout, these are handled by View cross-platform metrics system and can be disabled if necessary.

Properties of default face types can be customized to the extent allowed by underlying backend's limitations and abstracted away in a dedicated style: via VID `style` keyword, extension of the `system/view/VID/styles` list of templates, or with the help of prototype-based object inheritance.

In general, GUI applications made with Red are written at the high level of abstraction. Virtual tree of faces, being an amenable data structure, can be manipulated and extended at run-time with the basic set of language primitives. Such tree is commonly constructed in a semi-automated fashion, as a part of domain-specific dialect processing (such as VID) or metaprogramming facilities.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code.footnote:[See Boleslav Březovský's http://red.qyz.cz/writing-style.html[article] on custom VID styles as an example.] Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of the underlying backends.

High level of expressiveness is made possible by the synergy of language properties, such syntactically-rich type system and general orientation towards linguistic abstraction and simple semantics of all operations; indeed, both VID and View are the prime examples of this approach towards language design.

#### Closeness of mapping

> How closely does the notation correspond to the problem world?

Historically, object-oriented programming (OOP) is a prevalent paradigm when it comes to GUI construction,footnote:[See introductory chapter in Eugen Kiss' thesis.] the same holds with Red as well: hierarchical composition of stateful objects reflects the underlying structure of modeled graphical interface; prototype-based inheritance ensures that all faces have same properties (such as position, size, visibility), yet each instance is unique in the way said properties are used and customized; object ownership system and reactivity make real-time user interaction possible.

Usage of actors and event-based model has a low conceptual overhead, since they rely on intuitive notions of causality and law of action-reaction. Each face is modeled as a receiver of events being pushed onto it, and although face object has a complete control on how events are processed and reacted upon, the flow of events itself is outside of its purview.

This suffices for interface-building and https://dl.acm.org/doi/10.1145/800027.808431[programming in the small] that View and VID are primarily designed for, but presents a challenging inversion of control for tasks of a larger scale, and those coming from different problem domains: where source of events produces more information than receiver can handle if they are forcefuly pushed onto it, thus clogging the throughput, such as real-time animation, asynchronous data processing, interaction with multiple network services.

Again, historically, Functional Reactive Programming (FRP) is a paradigm that maps closely than OOP to this type of use-cases. Supporting FRP concepts in View presents an opportunity for Red to make a case for its paradigm-neutrality: port model coupled with https://github.com/red/docs/blob/master/en/parse.adoc[embedded parsing engine] and a https://github.com/red/docs/blob/master/en/datatypes.adoc[rich set of datatypes] provides a solid ground for creating an FRP-like Publish/Subscribe model based on pattern-matching event streams constructed from Red values.footnote:[A rudiment of this idea can be noticed in a reserved `system/view/event-port` field.]

When it comes to interface building, declarative VID specification tends to match the visual layout of widgets on the screen, and closely maps to a description that users themselves would provide when instantiating a GUI.footnote:[There exist an anecdotal https://lobste.rs/s/1kxz55/puny_gui_puppy_finder#c_nzxgog[evidence] of people understanding VID even without knowing Red.] And while VID covers static aspects of the GUI layout, support for dynamic features (such as adaptive resizing, flexboxes, spacers) is lacking. There exist user-made solutions for that,footnote:[See https://gitlab.com/hiiamboris/red-elastic-ui[Elastic UI] proof-of-concept.] but out-of-the-box, cross-platform support would be much preferrable and provide the lowest common denominator for use-cases that require adaptive layouts.

#### Hidden dependencies

> Are dependencies between entities in the notation visible or hidden? Is every dependency indicated in both directions? Does a change in one area of the notation lead to unexpected consequences?

If we consider VID as a notation, then the entities in it exist in two different forms: at the top level, these are layout positioning commands, style definitions, and face descriptions, which can be generalized under the term _specification_; at the lower level, it is the virtual tree of faces to which a set of specifications is compiled by a dialect processor (`layout` or `view`).

As such, dependencies can exist between entities on either level of abstraction:

- between the specifications;
- between the faces in a virtual tree.

Within a VID block, specifications are well-isolated between each other and follow a pre-defined format: container settings at the top, followed by style declarations and face-specific specs. However, a minor dependency lurking in there is the _positioning_ of facet values and options, as well as the placement of specifications relative to each other that influences the interface layout, unless the keywords that specify an absolute positioning are used.

To illustrate the point: inside a given VID specification, both background and foreground colors are denoted either by `tuple!` values (representing RGBA colors), by `issue!` values (representing colors in hex notation), or by words that are set to such values. When values of these types are placed in the specification, value at the lower series index corresponds to the background, and value at the higher series index relates to the foreground, regardless of the programmer's intention.

By extension, when one specification follows another, its associated widget is placed either below or to the right of its predecessor, according to the current layout mode. This relation of succession is imposed by the linearity of the notation, which is position-dependent. This dependency, however, is visible and is an intentional part of dialect's design.

If we take face as a notational entity, then hierarchical dependencies between faces are cleary indicated in the virtual tree of faces: `pane` facet contains a list of child faces arranged in a Z-order, and `parent` facet of a child face holds a backlink to its parent face.

Dependencies on reactive sources to which a given face can react during event processing can be discerned from `actors` facet. In turn, `react?` function can be used on a specific facet to see in what relation it acts as a source. Yet, long-range dependencies remain invisible, and could be explicated by a graph vizualisation of reactive relations. Event handlers are specified explicitly and are also visible in `actors` facet; but handlers can also be installed globally, in such case they become a hidden dependency.

Objects in Red act more like namespaces, and so there is no dependency or inheritance chain between a given object and a prototype from which it was derived. This nips the https://en.wikipedia.org/wiki/Fragile_base_class[fragile base class] problem (given as a classical example of hidden dependency in 7GUIs thesis) in the bud.

Conceptually, hidden dependency is a broken symmetry that acts as an inhibitor of the finding process: once a change to the notational entity is made, consequences of such change, if not already apparent from the outset, need to be deduced by following the one-way causal relationships with other entities, which might not even be indicated at all.

Environmental clues, such as embedded docstrings and integrated help system, as well as Integrated Development Environment (IDE) facilities, provide a compensatory function for such search costs, to a certain extent. This is the general line of development that Red and its eDSLs seem to pursue even in their nascent state: aiming at living environments rather than static artefacts, favoring interactive tools over supplemental tutorials.

Compact and human-friendly code constitutes an integral part of VID's appeal; overloading it with an explicit information and mandatory constructs would indicate hidden dependencies more clearly, at the expence of becoming extremely scrupulous and sacrificing dialect's notational qualities, such as expressiveness and brewity.

#### Error-proneness

> To what extent does the notation influence the likelihood of the user making a mistake?

The nature of VID as an eDSL is a double edged sword: it is a language with a well-defined problem domain and semantics, which nethertheless is embedded in the host, and relies on the behavior of its datatypes with evaluation model. Such "chimerical" nature of Red dialects provides the necessary leverage and reduces the complexity of a given task, but is often tends to be misunderstood: either by ignoring dialect's specificities or by forgetting its relation to the base language.

Arguably, one the most problematic aspect of Red GUI system is it's reliance on language's name resolution mechanism called "binding" or sometimes "definitional scoping" coupled with an absence of modules or easy ways to localize or re-bind names without writing boilerplate code. Symbolic identifiers introduced in VID block (for example, in the body of an event handler) by default resolve to the global namespace, and often tend to shadow other definitions, which leads to hard to catch bugs.footnote:[See one of the https://github.com/red/red/issues/972#issuecomment-650814221[examples] on Red issue tracker, derived during the implementation of link:tasks/CRUD.red[CRUD] task.] Granted, this problem is not unique to VID, but rather presents a historical design challenge in the Rebol family of languages.

Another error-prone element is the structure of indirect values in Red -- that is, values that contain references to external, mutable and shareable data buffers. Modification of a buffer via one indirect value affects all the other indirect values that share the same buffer, unless said buffer is explicitly copied beforehand. While Red employs only call-by-value convention, to the uninitiated this language feature comes close to Java’s different calling semantics for primitive and reference types. In the context of View and VID, this comes up when facets (most commonly `data` or `text`) are re-used in many complex relations, or when a VID block containing indirect values (such as `string!` or `block!`) is generated with the help of meta-programming facilities.

View engine presents virtual tree of faces as a data-oriented, minimal programming interface to the underlying graphical backend. The common source of errors in it are not the hierarchical and reactive relations between faces,footnote:[The opposite happens in the rare cases where a tree of faces is constructed by hand and various hierarchical requirements (e.g. `screen` face as tree's root, double-linking of faces, specification of their types and event handlers) need to be fulfilled.] but the variability of facet's values. Objects' fields are not typed, in a sense that they can be set to any value, which in turn brings out a specific behavior dictated by its datatype. For example, in `color` facet, `tuple!` values change widget's background color, and `none!` value resets it to a default setting.

Given that VID recognizes both `tuple!` (RGBA) and `issue!` (hex-encoded) values as valid color denotations, a common mistake is to set `color` facet to `issue!` and expect a change in the background, whereas this setting is simply ignored. What seems to be required in such cases is _operational specification_, which would limit a given facet to a limited number of datatypes, and further restrict values on these datatypes to an allowed range: for example, `issue!` values that hex-encode colors, or `tuple!` values with strictly 3 or 4 elements. Object ownership system, on which the reactive framework is based, can achieve that.footnote:[See `system/locale/currencies` object, designed as a proof-of-concept for such form of object field's protocoling; it monitors the list of currencies and enforces only specific set of user interactions with it, constraining the content of the list not only to the values of specific datatype, but values with specific properties _within_ the datatype.]

Finally, errors can emerge during the user interaction with a created GUI: an unspecified event handler, a missed edge-case, an unanticipated scenario; manual or automated GUI testing can catch this form of mistakes, but is quite non-trivial to implement in platform-independent way. The initial work on https://gitlab.com/hiiamboris/red-view-test-system[Red/View testing framework] and existence of the https://www.red-lang.org/2017/07/063-macos-gui-backend.html[null backend] (described at the beginning of "View engine" section) set the stage for this line of development.

#### Diffuseness

> How many symbols or how much space does the notation require to produce a certain result or express a meaning?

To the best of author's knowledge,footnote:[Reviewing the official 7GUIs repository at commit https://github.com/eugenkiss/7guis/commit/dd339c88b7302e221340c8ee2335ce6124a88c54[`dd339c8`] and considering its pending pull requests.] only the https://eugenkiss.github.io/7guis/implementations[implementations] of 7GUIs tasks listed in the table below have completed all the https://eugenkiss.github.io/7guis/tasks[seven challenges] -- which is taken as a sign of GUI toolkit's capabilities. Source lines of code (SLOC) metrics of implementation files and their dependencies were taken as displayed by Github code viewer, and serve as an approximation of diffuseness' degree.

.SLOC count of complete 7GUIs implementations.
[%header,cols="<2,^,^,^,^,^,^,^,>"]
|===

| 
| Counter
| Temperature Converter
| Flight Booker
| Timer
| CRUD
| Circle Drawer
| Cells
| Total

| https://github.com/9214/7guis-red[Red]
| 12
| 18
| 39
| 19
| 70
| 72
| 87
| *317*

| https://github.com/eugenkiss/7guis-Clojure-Seesaw[Clojure, Seesaw]
| 14
| 35
| 76
| 43
| 77
| 90
| 140
| *485* ^†^

| https://github.com/eugenkiss/7guis-Scala-ScalaFX[Scala, ScalaFX]
| 29
| 36
| 57
| 50
| 87
| 128
| 219
| *606*

| https://github.com/area9innovation/flow9/tree/master/demos/7guis[Flow]
| 10
| 24
| 78
| 30
| 56
| 129
| 298
| *625*

| https://github.com/themoritz/7guis-reflex[Haskell, Reflex-DOM]
| 13
| 14
| 44
| 30
| 65
| 106
| 315
| *674* ^†^

| https://github.com/foam-framework/foam/tree/master/js/foam/demos/sevenguis[JavaScript, FOAM]
| 22
| 33
| 103
| 99
| 142
| 148
| 301
| *848*

| https://github.com/eugenkiss/7guis-Java8-JavaFX[Java 8, JavaFX]
| 26
| 57
| 71
| 52
| 83
| 224
| 468
| *981*

| https://github.com/petelomax/Phix/tree/master/demo/rosetta/7guis[Phix]
| 18
| 33
| 64
| 65
| 143
| 204
| 424
| *1041*

| https://github.com/eugenkiss/7guis-Java7-Swing[Java 7, Swing]
| 38
| 78
| 143
| 88
| 213
| 233
| 468
| *1261*

| https://github.com/andrewgreenh/7guis[JavaScript, React]
| 26
| 80
| 100
| 85
| 248
| 234
| 641
| *1575* ^†^

| https://github.com/eugenkiss/7guis-React-TypeScript-MobX[TypeScript, React, MobX]
| 15
| 106
| 105
| 96
| 105
| 391
| 481
| *1585* ^†^

|===

[small.text-right]
Clojure, Seesaw:: 10 SLOC of external scaffolding.
Haskell, Reflex-DOM:: 87 SLOC of helper libraries.
JavaScript, React:: 161 SLOC of helper libraries.
TypeScript, React, MobX:: 279 SLOC of external scaffolding, 7 SLOC of helpers.

It follows that the Red implementation under discussion is the smallest fully functional one in terms of the total SLOC count, even with the leg-up of counting non-essential script headers containing meta-information (7 SLOC per task), taking the helping code under consideration (e.g. undo/redo functionality in <<_circle_drawer, Circle Drawer>>, formula parser and evaluator in <<_cells, Cells>>), and a bit excessive code formatting -- a by-product of adherance to the https://github.com/red/docs/blob/master/en/style-guide.adoc[official style guide] and avoidance of intentional code-golfing.

Indeed, Red programs generally show low levels of diffuseness and boilerplate, without extreme density (cf. APL family). Speaking of VID, not only the line count in it is low, but the number of distinct notational elements (at the level of symbolic description) is also quite modest: any given VID specification includes information about widget's positioning, the content of its facets, and provided event handlers. Parelleling the HTML/CSS/JS trichotomy, we might call these aspects _structure_, _style_ and _substance_.footnote:[Taking a certain ontological stance, one can name these aspects _essences_ that, when combined, form the notational entities.]

The main factors contributing to near-absence of diffuseness are meta-programming facilities (e.g. generating spreadsheet in <<_cells, Cells>>) and data-orientation: a small set of core primitives working seamlessly across the board, and acting on value literals that can produce the meaning of their own; syntax determines semantics.

#### Viscosity

> Are there any inherent barriers to change in the notation? How much effort is required to make a change to a program expressed in the notation?

Inherent dynamism and flexibility (and hense a low viscosity) always made the Rebol family of languages an appealing target for rapid code prototyping, as evidenced by a multitude of hot code reloading and live editing tools developed with it.footnote:[See https://www.red-lang.org/2016/07/eve-style-clock-demo-in-red-livecoded.html[Eve clock demo] and https://github.com/toomasv/layout-editor[UI mockup editor] as examples.] 3 factors play key role in that:

Homoiconic property:: By the virtue of which Red is not only a programming language, but also its own data format. That encourages keeping the programs data-driven, decoupled form frequently changing aspects that get factored out into dedicated textual configuration files and can be serialized into binary form if needed.
High degree of polymorphism:: Changing the datatype without changing the underlying interface (for example by switching between different types of `series!`) often requires little to no changes within the rest of the program.
Object ownership system:: Which endows entities within a language with so-called https://en.wikipedia.org/wiki/Autonomic_computing#Characteristics_of_autonomic_systems[self-* properties], giving them a certain degree of autonomy and allowing creation of various high-level frameworks and paradigms: forms of self-healing and self-protecting code, design by contract, etc. Reactive framework built on top of object ownership is what actually drives the responsiveness of the View engine. No changes need to be made, since the program can react and adapt to them by itself.

The questions of high viscosity is closely tied to intentionality: unintentional barriers to change inhibit the development process and require unwanted efforts to bypass them. At the same time, notation can introduce such barriers in order to prohibit certain unidiomatic operations within the framework by making them more difficult (e.g. constructing virtual tree of faces by hand rather than writing at least parts of it in declarative VID specifications), thus forcing the user to adopt a specific problem-solving mindset (cf. design patterns). Red posits itself as paradigm-neutral language in this regard and does not stand in the way, although it certainly lacks a proper support for functional programming.

As the program evolves from a minimal viable product (MVP) to production-ready application, its degree of viscosity also changes from flexibility to rigidity, accruing constraints and baked-in assumptions. With Red, very often the issue is not an excess of resistance to change, but rather the lack of it; and so the language perfectly fits the requirements of prototyping stages, where the speed of delivery, navigation of design space and communication with domain experts is more important than performance or even correctness. In some settings this turns out to be more than enough, and for others the application can be rewritten in a different notation (i.e. ported to a different language/framework) with desirable level of rigidity and strictness, e.g. static type discipline and amenability to formal proof.

Last but not least, in case of GUIs the biggest resistance to change comes from the differences between supported platforms: each of them enforces specific interface design guidelines and provides widgets that differ not only in form, but also in function. View provides rule-oriented GUI rewriting engine, capable of modifying a virtual tree of faces dynamically according to pre-defined platform-specific rules, such as button ordering and capitalization of widget's labels.footnote:[See `system/view/VID/GUI-rules` for details.]

## Tasks

NOTE: TBD.

https://eugenkiss.github.io/7guis/tasks

https://eugenkiss.github.io/7guis-React-TypeScript-MobX[Reference implementation] created with React, TypeScript and MobX.

Reference, rationale behind each task, samples.

Each section below evaluates respective task's solution according to the CD guidelines described in <<Introduction>>. See §3.1 ¶12.

### Counter

NOTE: TBD.

> Understanding the basic ideas of a language/toolkit and the essential scaffolding.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Temperature Converter

NOTE: TBD.

> Working with bi-directional dataflow, working with user-provided text input.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Flight Booker

NOTE: TBD.

> Working with constraints.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Complex predicates and guards.

### Timer

NOTE: TBD.

> Working with concurrency, working with competing user/signal interactions, keeping the application responsive.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### CRUD

NOTE: TBD.

> Separating the domain and presentation logic, managing mutation, building a non-trivial layout.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

MVC pattern.

### Circle Drawer

NOTE: TBD.

> Implementing undo/redo functionality, custom drawing, implementing dialog control (i.e. keeping context between successive GUI operations).

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Persistent data structures. Mention https://gist.github.com/numberjay/3df8f13044145c6dde1918ea2cdfe3b8[PoC]?. On-disk serialization with https://github.com/red/docs/blob/master/en/redbin.adoc[Redbin] format.

### Cells

NOTE: TBD.

> Implementing change propagation, customizing a widget, implementing a more authentic/involved GUI application.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Abstraction level -- abusing `field` as table cell widget and generating layout with metaprogramming.

`gob!`-based spreadsheets and limits of the current approach.

## Desiderata

NOTE: TBD.

WARNING: Most of this is a copypaste from other sections.

NOTE: See also 'Ideas' folder on Notion. Table with TL;DR of an idea -> section number.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code. Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of underlying backends.

---

However, existing approach to GUI creation doesn't scale well beyond small applications. Internally, View engine relies on OS-provided native graphical components, which can be resource-heavy and not as performant as one wants them to be. Such limited set of components is constrained in graphical look and customization options, which makes it harder to adapt them to domain-specific needs.

Declarative style of VID is not modular and does not permit a level of flexibility necessary to handle large projects: visual layout of widgets, their properties and event-handling logic, while logically separate, tend to be conflated together at the level of VID description.

Existing notation coupled with above-mentioned Red language properties provides means of addressing this concerns; conceptually, however, there seems to be a need for a eDSL with different type of semantics, and for an extension of graphical engine with more lightweight, platform-independent and customizable graphical primitives.footnote:[Such as http://www.rebol.com/r3/docs/view/gobs.html[Rebol3 Graphical Objects] (GOBs).]

---

Again, historically, Functional Reactive Programming (FRP) is a paradigm that maps closely than OOP to this type of use-cases. Supporting FRP concepts in View presents an opportunity for Red to make a case for its paradigm-neutrality: port model coupled with embedded parsing engine and a rich set of datatypes provides a solid ground for creating an FRP-like Publish/Subscribe model based on pattern-matching event streams constructed from Red values.

---

When it comes to interface building, declarative VID specification tends to match the visual layout of widgets on the screen, and closely maps to a description that users themselves would provide when instantiating a GUI. And while VID covers static aspects of the GUI layout, support for dynamic features (such as adaptive resizing, flexboxes, spacers) is lacking. There exist user-made solutions for that, but out-of-the-box, cross-platform support would be much preferrable and provide a lowest common denominator for use-cases that require adaptive layouts.

---

Accessibility, localization (cf. RebGUI)

---

The content of specification, rather than its relative positioning, can also implicitly infuence widget's properties. For example, `slider` or `progress` faces can become either vertical or horizontal, depending on which of its dimensions, denoted by a `pair!` value, is larger; on Win32 backend, size of the `calendar` widget changes the style of its display.

Any given specification includes information about widget's positioning, the content of its facets, and provided event handlers. Parelleling the HTML/CSS/JS trichotomy, we might call these aspects _structure_, _style_ and _substance_, which in VID tend to be conflated at the level of description. On the one hand, this leads to a more compact and human-friendly code; together with View engine's automatic handling of many GUI aspects, this constitutes an integral part of VID's appeal. On the other hand, such absence of modularity makes position-dependency of notational elements even more apparent.

On the other side of the spectrum, virtual tree of faces clearly separates the outlined aspets and is more granular, at the expence of being less expressive (in terms of notational qualities) than a VID block. A middle ground would be a new kind of dialect, designed with ease of code generation in mind (e.g. for high-level compilers that would target this dialect), where description of each aspect is notationally rich, reactive, and non-hierarchical, yet exists independently from all the others.footnote:[Henrik Mikael Kristensen https://gitter.im/red/red?at=5f749a589331433de02abdd6[discusses] a similar tripartite and layered approach in the design of a Draw-based dialect. Rudiments of such modularity are also present in http://www.dobeash.com/rebgui.html[RebGUI] system built on top of Rebol/View.]

---

Lack of meaningful complexity metrics for non-mainstream languages. Most of the work in this area was done at the early stages of CS&SE field.

---

## Conclusion

NOTE: TBD.

> Toolkit dominates paradigm for small applications.

Proliferation of spreadsheets and NoCode / LowCode solutions might require a different model. CRUD-oriented dialect with automatic generation of interfaces e.g. for databases, smart contracts (duh).
