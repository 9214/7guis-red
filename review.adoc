:toc:
:numbered:

# Red GUI System: a Case Study

## Introduction

This writeup presents analysis of https://www.red-lang.org/[Red programming language]'s approach to Graphical User Interface (GUI) programming in the form of a case study. It concerns itself with https://eugenkiss.github.io/7guis/tasks[7GUIs tasks] implemented in Red, and was conceived as a research on potential improvements in its https://github.com/red/docs/blob/master/en/gui.adoc[GUI system]: cross-platform graphical engine (View), embedded Domain-Specific Language (eDSL) for declarative user interface specification (Visual Interface Dialect, VID) and, to a lesser extent, eDSL for drawing raster graphics (Draw).footnote:[Due to specificity of 7GUIs tasks Rich-Text Dialect (RTD) was not evaluated.]

The study loosely follows the methodology outlined in https://github.com/eugenkiss/7guis/blob/master/thesis.pdf[Eugen Kiss' thesis] that originally presented the idea of benchmarking GUI toolkits in terms of their notational qualities; said benchmark is based on implementing seven GUI-related challenges and evaluating solutions to them using a subset of https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations[Cognitive Dimensions of Notations] (CD) criteria.

The implementation in question is hosted in https://github.com/9214/7guis-red[Github repository], along with the original version of this writeup.

### Overview

A general overview of Red's GUI system in terms of CD is given so as to explain the basic principles, terminology, and conceptual framework pertinent to the case study and all provided solutions; it can be skipped if the reader is familiar with the subject at hand.

#### Abstraction level

> What are the minimum and maximum levels of abstraction exposed by the notation? Can details be encapsulated?

At the lowest level of abstraction GUI is represented as a virtual tree of reactive objects (faces); each such object holds an internal state relevant to a widget that it represents, and inherits its properties from a `face!` prototype.

User interaction happens in an event-based fashion, via a mechanism of https://github.com/red/docs/blob/master/en/view.adoc#two-way-binding[two-way binding]: changes in the underlying OS-specific widget are mapped onto object's state and trigger specified event handlers (actors), and changes in one of the object's properties (facets) are reflected back into widget.

Communication between faces (or faces and domain model) is achieved with the help of object ownership system and https://github.com/red/docs/blob/master/en/reactivity.adoc[reactive framework] built on top of it; graphical component updates can be handled either automatically or with manual change propagation.

Constructing virtual tree of faces manually requires proper initialization of each object and its interconnection with parent and child nodes; this is a cumbersome and error-prone process. As such, at the hight level of abstraction user interface is typically described in declarative fashion via VID dialect, and tree of faces is constructed from such description with one of the View's user-facing functions, `view` or `layout`.

Red GUI system provides a common subset of face types supported by all graphical backends (Win32, Cocoa, GTK, Android). Each backend provides a specific set of guidelines for widget's layout, these are handled by View cross-platform metrics system and can be disabled if necessary.

Properties of default face types can be customized to the extent allowed by underlying backend's limitations and abstracted away in a dedicated style: via VID `style` keyword, extension of the `system/view/VID/styles` list of templates, or with the help of prototype-based object inheritance.

In general, GUI applications made with Red are written at the high level of abstraction. Virtual tree of faces, being an amenable data structure, can be manipulated and extended at run-time with the basic set of language primitives. Such tree is commonly constructed in a semi-automated fashion, as a part of domain-specific dialect processing (such as VID) or metaprogramming facilities.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code.footnote:[See Boleslav Březovský's http://red.qyz.cz/writing-style.html[article] on custom VID styles as an example.] Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of the underlying backends.

High level of expressiveness is made possible by the synergy of language properties, such as homoiconicity, high degree of polymorphism, syntactically-rich type system and general orientation towards linguistic abstraction and simple semantics of all operations; indeed, both VID and View are the prime examples of this approach towards language design.

#### Closeness of mapping

> How closely does the notation correspond to the problem world?

Historically, object-oriented programming (OOP) is a prevalent paradigm when it comes to GUI construction,footnote:[See introductory chapter in Eugen Kiss' thesis.] the same holds with Red as well: hierarchical composition of stateful objects reflects the underlying structure of modeled graphical interface; prototype-based inheritance ensures that all faces have same properties (such as position, size, visibility), yet each instance is unique in the way said properties are used and customized; object ownership system and reactivity make real-time user interaction possible.

Usage of actors and event-based model has a low conceptual overhead, since they rely on intuitive notions of causality and law of action-reaction. Each face is modeled as a receiver of events being pushed onto it, and although face object has a complete control on how events are processed and reacted upon, the flow of events itself is outside of its purview.

This suffices for interface-building and https://dl.acm.org/doi/10.1145/800027.808431[programming in the small] that View and VID are primarily designed for, but presents a challenging inversion of control for tasks of a larger scale, and those coming from different problem domains: where source of events produces more information than receiver can handle if they are forcefuly pushed onto it, thus clogging the throughput, such as real-time animation, asynchronous data processing, interaction with multiple network services.

Again, historically, Functional Reactive Programming (FRP) is a paradigm that maps closely than OOP to this type of use-cases. Supporting FRP concepts in View presents an opportunity for Red to make a case for its paradigm-neutrality: port model coupled with https://github.com/red/docs/blob/master/en/parse.adoc[embedded parsing engine] and a https://github.com/red/docs/blob/master/en/datatypes.adoc[rich set of datatypes] provides a solid ground for creating an FRP-like Publish/Subscribe model based on pattern-matching event streams constructed from Red values.footnote:[A rudiment of this idea can be noticed in a reserved `system/view/event-port` field.]

When it comes to interface building, declarative VID specification tends to match the visual layout of widgets on the screen, and closely maps to a description that users themselves would provide when instantiating a GUI.footnote:[There exist an anecdotal https://lobste.rs/s/1kxz55/puny_gui_puppy_finder#c_nzxgog[evidence] of people understanding VID even without knowing Red.] And while VID covers static aspects of the GUI layout, support for dynamic features (such as adaptive resizing, flexboxes, spacers) is lacking. There exist user-made solutions for that,footnote:[See https://gitlab.com/hiiamboris/red-elastic-ui[Elastic UI] proof-of-concept.] but out-of-the-box, cross-platform support would be much preferrable and provide the lowest common denominator for use-cases that require adaptive layouts.

#### Hidden dependencies

WARNING: Looks too far-fetched; spread between error-proness (e.g. binding) and difuseness (e.g. VID vs. RebGUI).

> Are dependencies between entities in the notation visible or hidden? Is every dependency indicated in both directions? Does a change in one area of the notation lead to unexpected consequences?

If we consider VID as a notation, then the entities in it exist in two different forms: at the top level, these are layout positioning commands, style definitions, and face descriptions, which can be generalized under the term _specification_; at the lower level, it is the virtual tree of faces to which a set of specifications is compiled by a dialect processor (`layout` or `view`).

As such, dependencies can exist between entities on either level of abstraction:

- between the elements of specifications;
- between the faces in a virtual tree, or between their facets.

Within a VID block, specifications are well-isolated between each other and follow a pre-defined format: container settings at the top, followed by style declarations and face-specific specs. However, a minor dependency lurking in there is the _positioning_ of facet values and options, as well as the placement of specifications relative to each other that influences the interface layout, unless the keywords that specify an absolute positioning are used.

To illustrate the point: inside a given VID specification, both background and foreground colors are denoted either by `tuple!` values (representing RGBA colors), by `issue!` values (representing colors in hex notation), or by words that are set to such values. When values of these types are placed in the specification, value at the lower series index corresponds to the background, and value at the higher series index relates to the foreground, regardless of the programmer's intention.

By extension, when one specification follows another, its associated widget is placed either below or to the right of its predecessor, according to the current layout mode. This relation of succession is imposed by the linearity of the notation, which is position-dependent. This dependency, however, is visible and is an intentional part of dialect's design.

The content of specification, rather than its relative positioning, can also implicitly infuence widget's properties. For example, `slider` or `progress` faces can become either vertical or horizontal, depending on which of its dimensions, denoted by a `pair!` value, is larger; on Win32 backend, size of the `calendar` widget changes the style of its display.

Any given specification includes information about widget's positioning, the content of its facets, and provided event handlers. Parelleling the HTML/CSS/JS trichotomy, we might call these aspects _structure_, _style_ and _substance_, which in VID tend to be conflated at the level of description. On the one hand, this leads to a more compact and human-friendly code; together with View engine's automatic handling of many GUI aspects, this constitutes an integral part of VID's appeal. On the other hand, such absence of modularity makes position-dependency of notational elements even more apparent.footnote:[Taking a certain ontological stance, one can name these aspects _essences_ that, when combined, form the notational entities.] In turn, the excess of hand-holding prevents any sort of fine-grained control over the user interface.

On the other side of the spectrum, virtual tree of faces clearly separates the outlined aspets and is more granular, at the expence of being less expressive (in terms of notational qualities) than a VID block. A middle ground would be a new kind of dialect, designed with ease of code generation in mind (e.g. for high-level compilers that would target this dialect), where description of each aspect is notationally rich, reactive, and non-hierarchical, yet exists independently from all the others.footnote:[Henrik Mikael Kristensen https://gitter.im/red/red?at=5f749a589331433de02abdd6[discusses] a similar tripartite and layered approach in the design of a Draw-based dialect. Rudiments of such modularity are also present in http://www.dobeash.com/rebgui.html[RebGUI] system built on top of Rebol/View.]

If we take face as a notational entity, then hierarchical dependencies between faces are cleary indicated in the virtual tree of faces: `pane` facet contains a list of child faces arranged in a Z-order, and `parent` facet of a child face holds a backlink to its parent face.

Dependencies on reactive sources to which a given face can react during event processing can be discerned from `actors` facet. In turn, `react?` function can be used on a specific facet to see in what relation it acts as a source. Yet, long-range dependencies remain invisible. Event handlers are specified explicitly and are also visible in `actors` facet; but handlers can also be installed globally, in such case they become a hidden dependency.

Objects in Red act more like namespaces, and so there is no dependency or inheritance chain between a given object and a prototype from which it was derived. This nips the https://en.wikipedia.org/wiki/Fragile_base_class[fragile base class] problem (given as a classical example of hidden dependency in 7GUIs thesis) in the bud.

One notable feature is auto-synchronization kept by View engine between `data` and `text` facets in `text` and `field` faces. Done for the sake of convenience, it nevertheless is not explicitly indicated in VID specification or face state, and therefore forms a hidden dependency.

Arguably, the most problematic hidden dependency present in Red GUI system is it's reliance on language's name resolution mechanism called "binding" or sometimes "definitional scoping" coupled with an absence of modules or easy ways to localize names without writing boilerplate code. Symbolic identifiers introduced in VID block (for example, in the body of an event handler) by default resolve to the global namespace, and often tend to shadow other definitions, which sometimes leads to hard to catch bugs.footnote:[See one of the https://github.com/red/red/issues/972#issuecomment-650814221[examples] on Red issue tracker, derived during implementation of the link:tasks/CRUD.red[CRUD] task.] Granted, this problem is not unique to VID, but rather presents a historical design challenge in the Rebol family of languages.

Conceptually, hidden dependency is a broken symmetry that acts as an inhibitor of the finding process: once a change to the notational entity is made, consequences of such change, if not already apparent from the outset, need to be deduced by following the one-way causal relationships with other entities, which might not even be indicated at all.

Environmental clues, such as up-to-date and readily-available reference documentation, as well as Integrated Development Environment (IDE), provide a compensatory function for such search costs, to a certain extent.

NOTE: TBD.

Documentation -> compensatory function for a search cost of a hidden dependency, w/o sacrificing VID's notational qualities (tersness, implicitness, directness and semantic density). Hidden dependency is one-way and local; it is a slowing down of information search. Are tolerable during creation, but not modification, esp. for programming in the large.

Hidden dependencies are delegated to reference documentation which the user is assumed to consult. But there's no embedded, interactive documentation for VID (or any other dialect), nor a "bird's eye overview" indication of dependencies. An unsolved problem in genral for eDSLs in Red. IDE, tooltips. Link to some experiments and PoC from e.g. @toomasv.

In a certrain sense, knowledge of behavior and various subleties is a hidden dependency of a programmer on reference docs. Cognitive overhead of learning DSLs. Terseness, implicitness, elegance and tacicity are notational qualities, which might become a stumbling block for beginners. OTOH, too much explicity and it becomes a burden in general cases. Data-oriented -> values encode semantics.

(In)expectancy in Red (and, by extension, VID) are almost always tied to (in)experience.

Backlink from face to VID spec that it was generated from (if any), e.g. an index into a VID block, which can also be reactive. Bx, lenses (why tho?).

#### Error-proneness

> To what extent does the notation influence the likelihood of the user making a mistake?

NOTE: TBD.

Facets, when being set, react differently depending on the type of the value: there's a list of accepted datatypes to which it can react, but it's not indicated anywhere other than documentation; e.g. `color` facet accepts `tuple!` but not a hex-encoded `issue!` (on the contrary, VID block accepts both types of values as encodings of colors). Data-oriented, minimal API, virtual tree of faces as a programming interface -- needs "protocoling".

modification w/o `copy` (shared series buffers), no type-checking for face's fields (repurpose https://gitter.im/red/red?at=5f24151036563560f2b4cb06[this]), Secure dialect as a "bondage & discipline" for this general class of problems + ownership system. Constants, mutability. Indexing in Draw with relative offsets (Circles).

Forgetting that VID is a DSL, trying to embed regular Red code.

The question of GUI testing: manual, automatic, link to Boris' work. Existence of a null backend.

#### Diffuseness

> How many symbols or how much space does the notation require to produce a certain result or express a meaning?

NOTE: TBD.

Generally low level of diffuseness and boilerplate. 270 LOC without intentional code-golfing. Take time to compare with other notable implementations (e.g. Eugiene's, or popular GUI frameworks like Qt or WxWidget).

Metaprogramming (e.g. generating cells). Static and dynamic ways of creating reactive relations (cite the docs?).

Cells -- conditional expressions that guard the change of cell's state, FSM-like dialect. High degree of polymorphism, small set of actions working seamlessly across the board. Value literals can produces the meaning of their own (e.g. RGB `tuple!`, hex `issue!`) -- syntax determines semantics. 

#### Viscosity

> Are there any inherent barriers to change in the notation? How much effort is required to make a change to a program expressed in the notation?

NOTE: TBD.

Inherent dynamism of the language, hot code reloading, live editing (Eve clock demo). Very often the problem is not an excess of resistance to change, but the lack of it. Data-driven, configuration.

## Tasks

NOTE: TBD.

https://eugenkiss.github.io/7guis/tasks

https://eugenkiss.github.io/7guis-React-TypeScript-MobX[Reference implementation] created with React, TypeScript and MobX.

Reference, rationale behind each task, samples.

Each section below evaluates respective task's solution according to the CD guidelines described in <<Introduction>>. See §3.1 ¶12.

### Counter

NOTE: TBD.

> Understanding the basic ideas of a language/toolkit and the essential scaffolding.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Temperature Converter

NOTE: TBD.

> Working with bi-directional dataflow, working with user-provided text input.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Flight Booker

NOTE: TBD.

> Working with constraints.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Complex predicates and guards.

### Timer

NOTE: TBD.

> Working with concurrency, working with competing user/signal interactions, keeping the application responsive.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### CRUD

NOTE: TBD.

> Separating the domain and presentation logic, managing mutation, building a non-trivial layout.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

MVC pattern.

### Circle Drawer

NOTE: TBD.

> Implementing undo/redo functionality, custom drawing, implementing dialog control (i.e. keeping context between successive GUI operations).

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Persistent data structures. Mention https://gist.github.com/numberjay/3df8f13044145c6dde1918ea2cdfe3b8[PoC]?.

### Cells

NOTE: TBD.

> Implementing change propagation, customizing a widget, implementing a more authentic/involved GUI application.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Abstraction level -- abusing `field` as table cell widget and generating layout with metaprogramming.

`gob!`-based spreadsheets and limits of the current approach.

## Desiderata

NOTE: TBD.

WARNING: Most of this is a copypaste from other sections.

NOTE: See also 'Ideas' folder on Notion. Table with TL;DR of an idea -> section number.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code. Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of underlying backends.

---

However, existing approach to GUI creation doesn't scale well beyond small applications. Internally, View engine relies on OS-provided native graphical components, which can be resource-heavy and not as performant as one wants them to be. Such limited set of components is constrained in graphical look and customization options, which makes it harder to adapt them to domain-specific needs.

Declarative style of VID is not modular and does not permit a level of flexibility necessary to handle large projects: visual layout of widgets, their properties and event-handling logic, while logically separate, tend to be conflated together at the level of VID description.

Existing notation coupled with above-mentioned Red language properties provides means of addressing this concerns; conceptually, however, there seems to be a need for a eDSL with different type of semantics, and for an extension of graphical engine with more lightweight, platform-independent and customizable graphical primitives.footnote:[Such as http://www.rebol.com/r3/docs/view/gobs.html[Rebol3 Graphical Objects] (GOBs).]

---

Again, historically, Functional Reactive Programming (FRP) is a paradigm that maps closely than OOP to this type of use-cases. Supporting FRP concepts in View presents an opportunity for Red to make a case for its paradigm-neutrality: port model coupled with embedded parsing engine and a rich set of datatypes provides a solid ground for creating an FRP-like Publish/Subscribe model based on pattern-matching event streams constructed from Red values.

---

When it comes to interface building, declarative VID specification tends to match the visual layout of widgets on the screen, and closely maps to a description that users themselves would provide when instantiating a GUI. And while VID covers static aspects of the GUI layout, support for dynamic features (such as adaptive resizing, flexboxes, spacers) is lacking. There exist user-made solutions for that, but out-of-the-box, cross-platform support would be much preferrable and provide a lowest common denominator for use-cases that require adaptive layouts.

---

Accessibility, localization (cf. RebGUI)

---

## Conclusion

NOTE: TBD.

> Toolkit dominates paradigm for small applications.

Proliferation of spreadsheets and NoCode / LowCode solutions might require a different model. CRUD-oriented dialect with automatic generation of interfaces e.g. for databases, smart contracts (duh).
