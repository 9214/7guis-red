:toc:
:numbered:

# Red GUI System: a Case Study

## Introduction

This writeup presents analysis of https://www.red-lang.org/[Red programming language]'s approach to Graphical User Interface (GUI) programming in the form of a case study. It concerns itself with https://eugenkiss.github.io/7guis/tasks[7GUIs tasks] implemented in Red, and was conceived as a research on potential improvements in its https://github.com/red/docs/blob/master/en/gui.adoc[GUI system]: cross-platform graphical engine (View), embedded Domain-Specific Language (eDSL) for declarative user interface specification (Visual Interface Dialect, VID) and, to a lesser extent, eDSL for drawing raster graphics (Draw).footnote:[Due to specificity of 7GUIs tasks Rich-Text Dialect (RTD) was not evaluated.]

The study closely follows the methodology outlined in https://github.com/eugenkiss/7guis/blob/master/thesis.pdf[Eugen Kiss' thesis] that originally presented the idea of benchmarking GUI toolkits in terms of their notational qualities; said benchmark is based on implementing seven GUI-related challenges and evaluating solutions to them using a subset of https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations[Cognitive Dimensions of Notations] (CD) criteria.

The implementation in question is hosted in https://github.com/9214/7guis-red[Github repository], along with the original version of this writeup.

### Overview

A general overview of Red's GUI system in terms of CD is given so as to explain the basic principles and conceptual framework pertinent to the case study and all provided solutions; it can be skipped if the reader is familiar with the subject at hand.

#### Abstraction level

> What are the minimum and maximum levels of abstraction exposed by the notation? Can details be encapsulated?

At the lowest level of abstraction GUI is represented as a virtual tree of reactive objects (faces); each such object holds an internal state relevant to a widget that it represents, and inherits its properties from a `face!` prototype.

User interaction happens in an event-based fashion; changes in the underlying OS-specific widget are mapped onto object's state and trigger specified event handlers (actors), and changes in one of the object's properties (facets) are reflected back into widget.

Communication between faces (or faces and domain model) is achieved with the help of object ownership system and https://github.com/red/docs/blob/master/en/reactivity.adoc[reactive framework] built on top of it; graphical component updates can be handled either automatically or with manual change propagation.

Constructing virtual tree of faces manually requires proper initialization of each object and its interconnection with parent and child nodes; this is a cumbersome and error-prone process. As such, at the hight level of abstraction user interface is typically described in declarative fashion via VID dialect, and tree of faces is constructed from such description with one of the View's user-facing functions, `view` or `layout`.

Red GUI system provides a common subset of face types supported by all graphical backends (Win32, Cocoa, GTK, Android). Each backend provides a specific set of guidelines for widget's layout, these are handled by View cross-platform metrics system and can be disabled if necessary.

Properties of default face types can be customized to the extent allowed by underlying backend's limitations and abstracted away in a dedicated style: via VID `style` keyword, extension of the `system/view/VID/styles` list of templates, or with the help of prototype-based object inheritance.

In general, GUI applications made with Red are written at the high level of abstraction. Virtual tree of faces, being an amenable data structure, can be manipulated and extended at run-time with the basic set of language primitives. Such tree is commonly constructed in a semi-automated fashion, as a part of domain-specific dialect processing (such as VID) or metaprogramming facilities.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code.footnote:[See Boleslav Březovský's http://red.qyz.cz/writing-style.html[article] on custom VID styles as an example.] Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of the underlying backends.

High level of expressiveness is made possible by the synergy of language properties, such as homoiconicity, high degree of polymorphism, syntactically-rich type system and general orientation towards linguistic abstraction and simple semantics of all operations; indeed, both VID and View are the prime examples of this approach towards language design.

#### Closeness of mapping

> How closely does the notation correspond to the problem world?

Historically, object-oriented programming (OOP) is a prevalent paradigm when it comes to GUI programming,footnote:[See introductory chapter in Eugen Kiss' thesis.] the same holds with Red as well: hierarchical composition of stateful objects reflects the underlying structure of modeled graphical interface; prototype-based inheritance ensures that all faces have same properties (such as position, size, visibility), yet each instance is unique in the way said properties are used and customized; object ownership system and reactivity make real-time user interaction possible.

Usage of actors and event-based model has a low conceptual overhead, since they rely on intuitive notions of causality and law of action-reaction. Each face is modeled as a receiver of events being pushed onto it, and although face object has a complete control on how events are processed and reacted upon, the flow of events itself is outside of its purview.

This suffices for interface-building and programming in the small that View and VID are primarily designed for, but presents a challenging inversion of control for tasks of a larger scale, and those coming from different problem domains: where source of events produces more information than receiver can handle if they are forcefuly pushed onto it, thus clogging the throughput, such as real-time animation, asynchronous data processing, interaction with multiple network services.

Again, historically, Functional Reactive Programming (FRP) is a paradigm that maps closely than OOP to this type of use-cases. Supporting FRP concepts in View presents an opportunity for Red to make a case for its paradigm-neutrality: port model coupled with embedded parsing engine and a rich set of datatypes provides a solid ground for creating an FRP-like Publish/Subscribe model based on pattern-matching event streams constructed from Red values.footnote:[A rudiment of this idea can be noticed in a reserved `system/view/event-port` field.]

When it comes to interface building, declarative VID specification tends to match the visual layout of widgets on the screen, and closely maps to a description that users themselves would provide when instantiating a GUI.footnote:[There exist an anecdotal https://lobste.rs/s/1kxz55/puny_gui_puppy_finder#c_nzxgog[evidence] of people understanding VID even without knowing Red.] And while VID covers static aspects of the GUI layout, support for dynamic features (such as adaptive resizing, flexboxes, spacers) is lacking. There exist user-made solutions for that,footnote:[See https://gitlab.com/hiiamboris/red-elastic-ui[Elastic UI] proof-of-concept.] but out-of-the-box, cross-platform support would be much preferrable and provide the lowest common denominator for use-cases that require adaptive layouts.

#### Hidden dependencies

> Are dependencies between entities in the notation visible or hidden? Is every dependency indicated in both directions? Does a change in one area of the notation lead to unexpected consequences?

NOTE: TBD.

Word's binding, shared series buffers, actor blocks as bodies of function with tacitly assumed arguments `face` and `event`, tacit assumption about the order of facet values in VID. Reactivity of facets. `pane` block and face's position in it, `parent`.

Explicit `on-*` handlers, global handlers. 

#### Error-proneness

> To what extent does the notation influence the likelihood of the user making a mistake?

NOTE: TBD.

#### Diffuseness

> How many symbols or how much space does the notation require to produce a certain result or express a meaning?

NOTE: TBD.

#### Viscosity

> Are there any inherent barriers to change in the notation? How much effort is required to make a change to a program expressed in the notation?

NOTE: TBD.

## Tasks

NOTE: TBD.

https://eugenkiss.github.io/7guis/tasks

https://eugenkiss.github.io/7guis-React-TypeScript-MobX/

Reference, rationale behind each task, samples.

Each section below evaluates respective task's solution according to the CD guidelines described in <<Introduction>>. See §3.1 ¶12.

### Counter

NOTE: TBD.

> Understanding the basic ideas of a language/toolkit and the essential scaffolding.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Temperature Converter

NOTE: TBD.

> Working with bi-directional dataflow, working with user-provided text input.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Flight Booker

NOTE: TBD.

> Working with constraints.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Complex predicates and guards.

### Timer

NOTE: TBD.

> Working with concurrency, working with competing user/signal interactions, keeping the application responsive.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### CRUD

NOTE: TBD.

> Separating the domain and presentation logic, managing mutation, building a non-trivial layout.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

MVC pattern.

### Circle Drawer

NOTE: TBD.

> Implementing undo/redo functionality, custom drawing, implementing dialog control (i.e. keeping context between successive GUI operations).

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Persistent data structures. Mention https://gist.github.com/numberjay/3df8f13044145c6dde1918ea2cdfe3b8[PoC]?.

### Cells

NOTE: TBD.

> Implementing change propagation, customizing a widget, implementing a more authentic/involved GUI application.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Abstraction level -- abusing `field` as table cell widget and generating layout with metaprogramming.

`gob!`-based spreadsheets and limits of the current approach.

## Desiderata

NOTE: TBD.

WARNING: Most of this is a copypaste from other sections.

NOTE: See also 'Ideas' folder on Notion.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code. Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of underlying backends.

---

However, existing approach to GUI creation doesn't scale well beyond small applications. Internally, View engine relies on OS-provided native graphical components, which can be resource-heavy and not as performant as one wants them to be. Such limited set of components is constrained in graphical look and customization options, which makes it harder to adapt them to domain-specific needs.

Declarative style of VID is not modular and does not permit a level of flexibility necessary to handle large projects: visual layout of widgets, their properties and event-handling logic, while logically separate, tend to be conflated together at the level of VID description.

Existing notation coupled with above-mentioned Red language properties provides means of addressing this concerns; conceptually, however, there seems to be a need for a eDSL with different type of semantics, and for an extension of graphical engine with more lightweight, platform-independent and customizable graphical primitives.footnote:[Such as http://www.rebol.com/r3/docs/view/gobs.html[Rebol3 Graphical Objects] (GOBs).]

---

Again, historically, Functional Reactive Programming (FRP) is a paradigm that maps closely than OOP to this type of use-cases. Supporting FRP concepts in View presents an opportunity for Red to make a case for its paradigm-neutrality: port model coupled with embedded parsing engine and a rich set of datatypes provides a solid ground for creating an FRP-like Publish/Subscribe model based on pattern-matching event streams constructed from Red values.

---

When it comes to interface building, declarative VID specification tends to match the visual layout of widgets on the screen, and closely maps to a description that users themselves would provide when instantiating a GUI. And while VID covers static aspects of the GUI layout, support for dynamic features (such as adaptive resizing, flexboxes, spacers) is lacking. There exist user-made solutions for that, but out-of-the-box, cross-platform support would be much preferrable and provide a lowest common denominator for use-cases that require adaptive layouts.

---

## Conclusion

NOTE: TBD.

> Toolkit dominates paradigm for small applications.

Proliferation of spreadsheets and NoCode / LowCode solutions might require a different model. CRUD-oriented dialect with automatic generation of interfaces e.g. for databases, smart contracts (duh).
