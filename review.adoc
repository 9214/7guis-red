:toc:
:numbered:

# Red GUI System: a Case Study

## Introduction

This writeup presents analysis of https://www.red-lang.org/[Red programming language]'s approach to Graphical User Interface (GUI) programming in the form of a case study. It concerns itself with https://eugenkiss.github.io/7guis/tasks[7GUIs tasks] implemented in Red, and was conceived as a research on potential improvements in its https://github.com/red/docs/blob/master/en/gui.adoc[GUI system]: cross-platform graphical engine (View), embedded Domain-Specific Language (eDSL) for declarative user interface specification (Visual Interface Dialect, VID) and, to a lesser extent, eDSL for drawing raster graphics (Draw).footnote:[Due to specificity of 7GUIs tasks Rich-Text Dialect (RTD) was not evaluated.]

The study closely follows the methodology outlined in https://github.com/eugenkiss/7guis/blob/master/thesis.pdf[Eugen Kiss' thesis] that originally presented the idea of benchmarking GUI toolkits in terms of their notational qualities; said benchmark is based on implementing seven GUI-related challenges and evaluating solutions to them using a subset of https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations[Cognitive Dimensions of Notations] (CD) criteria.

The implementation in question is hosted in https://github.com/9214/7guis-red[Github repository], along with the original version of this writeup.

### Overview

A general overview of Red's GUI system in terms of CD is given so as to explain the basic principles and conceptual framework pertinent to the case study and all provided solutions; it can be skipped if the reader is familiar with the subject at hand.

#### Abstraction level

> What are the minimum and maximum levels of abstraction exposed by the notation? Can details be encapsulated?

At the lowest level of abstraction GUI is represented as a virtual tree of reactive objects (faces); each such object holds an internal state relevant to a widget that it represents, and inherits its properties from a `face!` prototype.

User interaction happens in an event-based fashion; changes in the underlying OS-specific widget are mapped onto object's state and trigger specified event handlers (actors), and changes in one of the object's properties (facets) are reflected back into widget.

Communication between faces (or faces and domain model) is achieved with the help of object ownership system and https://github.com/red/docs/blob/master/en/reactivity.adoc[reactive framework] built on top of it; graphical component updates can be handled either automatically or with manual change propagation.

Constructing virtual tree of faces manually requires proper initialization of each object and its interconnection with parent and child nodes; this is a cumbersome and error-prone process. As such, at the hight level of abstraction user interface is typically described in declarative fashion via VID dialect, and tree of faces is constructed from such description with one of the View's user-facing functions, `view` or `layout`.

Red GUI system provides a common subset of face types supported by all graphical backends (Win32, Cocoa, GTK, Android). Each backend provides a specific set of guidelines for widget's layout, these are handled by View cross-platform metrics system and can be disabled if necessary.

Properties of default face types can be customized to the extent allowed by underlying backend's limitations and abstracted away in a dedicated style: via VID `style` keyword, extension of the `system/view/VID/styles` list of templates, or with the help of prototype-based object inheritance.

In general, GUI applications made with Red are written at the high level of abstraction. Virtual tree of faces, being an amenable data structure, can be manipulated and extended at run-time with the basic set of language primitives. Such tree is commonly constructed in a semi-automated fashion, as a part of domain-specific dialect processing (such as VID) or metaprogramming facilities.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code.footnote:[See Boleslav Březovský's http://red.qyz.cz/writing-style.html[article] on custom VID styles as an example.] Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of the underlying backends.

High level of expressiveness is made possible by the synergy of language properties, such as homoiconicity, high degree of polymorphism, syntactically-rich type system and general orientation towards linguistic abstraction and simple semantics of all operations; indeed, both VID and View are the prime examples of this approach towards language design.

#### Closeness of mapping

> How closely does the notation correspond to the problem world?

Historically, object-oriented programming (OOP) is a prevalent paradigm when it comes to GUI programmingfootnote:[See introductory chapter in Eugen Kiss' thesis.], the same holds with Red as well: hierarchical composition of stateful objects reflects the underlying structure of modeled graphical interface; prototype-based inheritance ensures that all faces have same properties (such as position, size, visibility), yet each instance is unique in the way said properties are used and customized; object ownership system and reactivity make real-time user interaction possible.

Usage of actors and event-based model has a low conceptual overhead, since they rely on intuitive notions of causality and law of action-reaction.

NOTE: TBD.

Red is considered paradigm-neutral, neither OO nor FP (the dichotomy that Eugen studies in his thesis). "Sustainability of FP in GUI development" ¶3.

Event-based framework, matching architectures of underlying backends (Win32, Cocoa, GTK). FRP and reification of event flow. Inversion of control (pub/sub?): right now events are pushed onto face, but it can instead pull them itself periodically. Listener, stream of events and pattern-matching on it. Each reactor maps stream of events from listeners to its own stream (to which other reactors can listen). Ports? Async interactions with external resources, emphasis is on continious, not discrete. Rich set of datatypes for modelling events, can contain contextual info. Orchestration (duh) of distributed services.

VID is declarative, description matches the visual layout. Anecdotal evidence of people understanding VID even without knowing Red.

https://lobste.rs/s/1kxz55/puny_gui_puppy_finder#c_nzxgog

And what is the "problem world"? So far Red was only concerned with small in-house applications. What about PITL, games, animation, plotting?

#### Hidden dependencies

> Are dependencies between entities in the notation visible or hidden? Is every dependency indicated in both directions? Does a change in one area of the notation lead to unexpected consequences?

NOTE: TBD.

#### Error-proneness

> To what extent does the notation influence the likelihood of the user making a mistake?

NOTE: TBD.

#### Diffuseness

> How many symbols or how much space does the notation require to produce a certain result or express a meaning?

NOTE: TBD.

#### Viscosity

> Are there any inherent barriers to change in the notation? How much effort is required to make a change to a program expressed in the notation?

NOTE: TBD.

## Tasks

NOTE: TBD.

https://eugenkiss.github.io/7guis/tasks

https://eugenkiss.github.io/7guis-React-TypeScript-MobX/

Reference, rationale behind each task, samples.

Each section below evaluates respective task's solution according to the CD guidelines described in <<Introduction>>. See §3.1 ¶12.

### Counter

NOTE: TBD.

> Understanding the basic ideas of a language/toolkit and the essential scaffolding.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Temperature Converter

NOTE: TBD.

> Working with bi-directional dataflow, working with user-provided text input.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### Flight Booker

NOTE: TBD.

> Working with constraints.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Complex predicates and guards.

### Timer

NOTE: TBD.

> Working with concurrency, working with competing user/signal interactions, keeping the application responsive.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

### CRUD

NOTE: TBD.

> Separating the domain and presentation logic, managing mutation, building a non-trivial layout.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

MVC pattern.

### Circle Drawer

NOTE: TBD.

> Implementing undo/redo functionality, custom drawing, implementing dialog control (i.e. keeping context between successive GUI operations).

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Persistent data structures. Mention https://gist.github.com/numberjay/3df8f13044145c6dde1918ea2cdfe3b8[PoC]?.

### Cells

NOTE: TBD.

> Implementing change propagation, customizing a widget, implementing a more authentic/involved GUI application.

*Abstraction level*

*Closeness of mapping*

*Hidden dependencies*

*Error-proneness*

*Diffuseness*

*Viscosity*

---

Abstraction level -- abusing `field` as table cell widget and generating layout with metaprogramming.

`gob!`-based spreadsheets and limits of the current approach.

## Desiderata

NOTE: TBD.

Creation of custom widgets with unique style (like e.g. material design) currently requires usage of `base` face, Draw dialect and external scaffolding in the form of event-processing and change-propagating code.footnote:[See Boleslav Březovský's http://red.qyz.cz/writing-style.html[article] on custom VID styles as an example.] Customization of the basic set of widgets is possible to a certain extent, but is ultimately limited due to specificities of underlying backends.

---

However, existing approach to GUI creation doesn't scale well beyond small applications. Internally, View engine relies on OS-provided native graphical components, which can be resource-heavy and not as performant as one wants them to be. Such limited set of components is constrained in graphical look and customization options, which makes it harder to adapt them to domain-specific needs.

Declarative style of VID is not modular and does not permit a level of flexibility necessary to handle large projects: visual layout of widgets, their properties and event-handling logic, while logically separate, tend to be conflated together at the level of VID description.

Existing notation coupled with above-mentioned Red language properties provides means of addressing this concerns; conceptually, however, there seems to be a need for a eDSL with different type of semantics, and for an extension of graphical engine with more lightweight, platform-independent and customizable graphical primitives.footnote:[Such as http://www.rebol.com/r3/docs/view/gobs.html[Rebol3 Graphical Objects] (GOB).]

---

## Conclusion

NOTE: TBD.

> Toolkit dominates paradigm for small applications.

Proliferation of spreadsheets and NoCode / LowCode solutions might require a different model. CRUD-oriented dialect with automatic generation of interfaces e.g. for databases, smart contracts (duh).
